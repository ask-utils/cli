const {Command, flags} = require('@oclif/command')
const {execFile} = require('child_process')
const fs = require('fs')
const yaml = require('js-yaml')
const chalk = require('chalk')

const npmInstall = (commands, self) => new Promise((resolve, reject) => {
  execFile('npm', commands, (error, stdout, stderr) => {
    self.log(stderr)
    if (error) {
      self.log(error)
      return reject(error)
    }
    self.log(stdout)
    return resolve(true)
  })
})
const createNpmInstallCommands = (packages, type = 'dev') => {
  switch (type) {
  case 'prod':
  case 'production': {
    const prodCommands = ['i', '-S']
    Array.prototype.push.apply(prodCommands, packages)
    return prodCommands
  }
  default: {
    const devCommands = ['i', '-D']
    Array.prototype.push.apply(devCommands, packages)
    return devCommands
  }
  }
}
const defaultPath = './lambda/custom'

class SetupCommand extends Command {
  async createSamTemplate() {
    this.log(chalk.green('[START]') + ' Generate SAM template.')
    const path = `${this.path}/template.yml`
    try {
      fs.readFileSync(path, 'utf8')
      this.log(chalk.red('[WARNING]') + ' SAM template file already exists.')
      this.exit(0)
    } catch (e) {
      if (e.code !== 'ENOENT') {
        this.log(e)
        this.exit(1)
        return
      }
    }
    const content = {
      AWSTemplateFormatVersion: '2010-09-09',
      Transform: 'AWS::Serverless-2016-10-31',
      Description: 'GENERATED BY ASK UTIL CLI',
      Resources: {
        AlexaFuncLogGroup: {
          Type: 'AWS::Logs::LogGroup',
          Properties: {
            LogGroupName: '/aws/lambda/${Alexa}', // eslint-disable-line no-template-curly-in-string
            RetentionInDays: 14,
          },
        },
        Alexa: {
          Type: 'AWS::Serverless::Function',
          Properties: {
            Handler: 'index.handler',
            Runtime: 'nodejs8.10',
            Environment: {
              Variables: {
                SKILL_NAME: 'Hello Alexa',
              },
            },
            Events: {
              Alexa: {
                Type: 'AlexaSkill',
              },
            },
          },
        },
      },
      Outputs: {
        AlexaFunction: {
          Description: 'Alexa Lambda Function ARN',
          Value: 'Alexa.Arn',
        },
      },
    }
    try {
      fs.writeFileSync(path, yaml.safeDump(content))
      this.log(chalk.green('[SUCCESS]') + 'SAM template generated.')
    } catch (e) {
      this.log(e)
      this.exit(1)
    }
  }

  async createServerlessYaml() {
    this.log(chalk.green('[START]') + ' Generate Serverless Framework template.')
    const path = `${this.path}/serverless.yml`
    try {
      fs.readFileSync(path, 'utf8')
      this.log(chalk.red('[WARNING]') + ' Serverless Framework template file already exists.')
      this.exit(0)
    } catch (e) {
      if (e.code !== 'ENOENT') {
        this.log(e)
        this.exit(1)
        return
      }
    }
    const content = {
      service: {
        name: 'YOUR_SKILL_NAME',
      },
      provider: {
        name: 'aws',
        runtime: 'nodejs8.10',
        logRetentionInDays: 30,
        iamRoleStatements: [
          {
            Effect: 'Allow',
            Action: [
              'dynamodb:*',
            ],
            Resource: [
              'arn:aws:dynamodb:{REGION}:*:table/{YOUR_SKILL_DB_NAME}',
            ],
          },
        ],
      },
      functions: {
        mySkill: {
          handler: 'index.handler',
          events: [
            {
              alexaSkill: 'YOUR_SKILL_ID',
            },
          ],
        },
      },
    }
    try {
      fs.writeFileSync(path, yaml.safeDump(content))
      this.log(chalk.green('[SUCCESS]') + 'Serverless Framework template generated.')
    } catch (e) {
      this.log(e)
      this.exit(1)
    }
  }

  async installLintPackages() {
    this.log('Installing lint packages by npm')
    const packages = ['eslint']
    const commands = createNpmInstallCommands(packages, 'dev')
    const current = process.cwd()
    try {
      process.chdir(this.path)
    } catch (e) {
      this.log(e)
      process.chdir(current)
      this.exit(1)
    }
    try {
      await npmInstall(commands, this)
    } catch (e) {
      this.log(e)
      process.chdir(current)
      this.exit(1)
    }
    process.chdir(current)
    this.log('Installed lint packages.')
  }

  async updatePackageJsonForLint() {
    let content
    const path = `${this.path}/package.json`
    try {
      content = fs.readFileSync(path, 'utf8')
    } catch (e) {
      if (e.code !== 'ENOENT') {
        this.log(e)
        this.exit(1)
        return
      }
    }
    const pkg = JSON.parse(content)
    if (pkg.scripts.lint) {
      this.log('[Skip] lint command is already defined.')
    }
    pkg.scripts.lint = './node_modules/.bin/eslint *.js'
    try {
      fs.writeFileSync(path, JSON.stringify(pkg, null, '\t'))
    } catch (e) {
      this.log(e)
      this.exit(1)
    }
  }

  async createEslintIgnore() {
    this.log('Add ESLint ignore file.')
    let content = ''
    const path = `${this.path}/.eslintignore`
    try {
      content = fs.readFileSync(path, 'utf8')
      if (/webpack.config.js/g.test(content)) return
    } catch (e) {
      if (e.code !== 'ENOENT') {
        this.log(e)
        this.exit(1)
        return
      }
    }
    content += '\nwebpack.config.js'
    try {
      fs.writeFileSync(path, content)
    } catch (e) {
      this.log(e)
      this.exit(1)
    }
    this.log('ESLint ignore file created.')
  }

  async createGitIgnore() {
    this.log('Add gitignore file.')
    let content = ''
    const path = `${this.path}/.gitignore`
    try {
      content = fs.readFileSync(path, 'utf8')
    } catch (e) {
      if (e.code !== 'ENOENT') {
        this.log(e)
        this.exit(1)
        return
      }
    }
    if (!/.serverless/g.test(content)) content += '\n.serverless/'
    if (!/.webpack/g.test(content)) content += '\n.webpack/'
    if (!/node_modules/g.test(content)) content += '\nnode_modules/'
    if (!/.envrc/g.test(content)) content += '\n.envrc/'
    if (!content) return
    try {
      fs.writeFileSync(path, content)
    } catch (e) {
      this.log(e)
      this.exit(1)
    }
    this.log('created .gitignore')
  }

  async run() {
    const {args, flags} = this.parse(SetupCommand)
    this.path = flags.path || defaultPath
    switch (args.type) {
    case 'gitignore': {
      await this.createGitIgnore()
      return
    }
    case 'sls':
    case 'serverless': {
      await this.createServerlessYaml()
      await this.createGitIgnore()
      return
    }
    case 'sam': {
      await this.createSamTemplate()
      return
    }
    case 'lint': {
      await this.installLintPackages()
      await this.updatePackageJsonForLint()
      await this.createEslintIgnore()
      return
    }
    case 'sam-all': {
      await this.createGitIgnore()
      await this.createSamTemplate()
      await this.installLintPackages()
      await this.updatePackageJsonForLint()
      await this.createEslintIgnore()
      return
    }
    case 'sls-all': {
      await this.createServerlessYaml()
      await this.createGitIgnore()
      await this.createGitIgnore()
      await this.createSamTemplate()
      await this.installLintPackages()
      await this.updatePackageJsonForLint()
      await this.createEslintIgnore()
    }
    }
  }
}

SetupCommand.description = `Describe the command here
...
Extra documentation goes here
`

SetupCommand.flags = {
  help: flags.help({char: 'h'}),
  path: flags.string({char: 'p', description: 'working dirctory path'}),
}
SetupCommand.args = [
  {
    name: 'type',
    required: true,
    description: 'lint, sam, serverless, test',
  },
]

module.exports = SetupCommand
